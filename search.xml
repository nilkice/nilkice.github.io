<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python基础之dict和set</title>
    <url>/2021/09/17/Python%E5%9F%BA%E7%A1%80%E4%B9%8Bdict%E5%92%8Cset/</url>
    <content><![CDATA[<h1 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h1><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><ul>
<li>概念：Python内置了字典—dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度</li>
<li>例如<pre><code>  * MathGrade = &#123;&#39;小明&#39; : 85, &#39;小红&#39; : 90, &#39;小白&#39; : 88&#125;
  * print(MathGrade[&#39;小红&#39;])
  * 90
</code></pre>
</li>
<li>给定键的名称，可以非常快的查找到对应的值</li>
<li>除了初始化指定键值对，还可以通过key放入<pre><code>  * MathGrade[&#39;小明&#39;] = 89
</code></pre>
</li>
<li>一个key只能有一个对应的value</li>
<li>key不存在时，插入value会出错</li>
<li>可以使用 in 来判断key是否存在<pre><code>  * print(&#39;小明&#39; in MathGrade)
  * True
</code></pre>
</li>
<li>还可以通过dict的get()方法来判断，返回对应的值，或者自己指定值<pre><code>  * grade = MathGrade.get(&#39;小明&#39;)
  * print(grade)
  * 85
  * -----分割线------
  * grade = MathGrade.get(&#39;小黄&#39;, -1)
  * print(grade)
  * -1
</code></pre>
</li>
<li>删除key，使用pop(key)，将对应的键值对全部删除<pre><code>  * MathGrade.pop(&#39;小明&#39;)
</code></pre>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>set和dict类似，也是一组key的集合，但不存储value，而且key不能重复</li>
<li>创建一个set，需要传入一个list集合<pre><code>  * s = set([1, 2, 3])
  * print(s)
  * &#123;1, 2, 3&#125;
</code></pre>
</li>
<li>重复的元素在set中自动被过滤</li>
<li>在set中添加元素<pre><code>  * s.add(4)
  * s.add(4)
  * print(s)
  * &#123;1, 2, 3, 4&#125;
</code></pre>
</li>
<li>删除set中的元素<pre><code>  * s.remove(4)
  * print(s)
  * &#123;1, 2, 3&#125;
</code></pre>
</li>
<li>set的并集，交集运算<pre><code>  * s1 = set([1, 2, 3])
  * s2 = set([1, 2, 4])
  * print(s1 &amp; s2)
  * &#123;1, 2&#125;
  * print(s1 | s2)
  * &#123;1, 2, 3, 4&#125;
</code></pre>
<h2 id="dict和list的区别"><a href="#dict和list的区别" class="headerlink" title="dict和list的区别"></a>dict和list的区别</h2></li>
<li>dict<ul>
<li>查找和插入的速度很快，不会随着key的增加而变慢</li>
<li>占用内存多，浪费严重</li>
</ul>
</li>
<li>list<ul>
<li>查找和插入的速度随着元素的增多而变慢</li>
<li>占用内存少<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2></li>
</ul>
</li>
<li>dict和set的元素都是不可变对象，因此不可将list作为其元素</li>
<li>原因是dict和set的实现由哈希表完成</li>
<li>本教程代码均在Visual Studio2019中实现</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>dict和set</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>HRB_Station</title>
    <url>/2021/09/11/HRB-Station/</url>
    <content><![CDATA[<h2 id="哈尔滨-9-11"><a href="#哈尔滨-9-11" class="headerlink" title="哈尔滨-9.11"></a>哈尔滨-9.11</h2><p><img src="https://cdn.jsdelivr.net/gh/nilkice/blog-img/IMG_0073.JPG"><br>九月十一号的哈尔滨火车站，我穿着短衣短袖在十多度的冷风中，差点没把我送走…</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之高级特性</title>
    <url>/2021/09/18/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Python的高级特性"><a href="#Python的高级特性" class="headerlink" title="Python的高级特性"></a>Python的高级特性</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul>
<li>在list，tuple，字符串中截取一段</li>
<li>截取范围含头不含为，因为索引下标是从0开始的</li>
</ul>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><ul>
<li>在python中只要是可迭代的对象，无论有无下标，都能迭代</li>
<li>如list，tuple，dict</li>
<li>判断一个对象是否为可迭代对象<ul>
<li>isinstance(判断对象, Iterable)</li>
<li>返回一个布尔值</li>
</ul>
</li>
</ul>
<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><ul>
<li>用来创建list的生成式<ul>
<li>如[x*x for x in range(1, 11)]</li>
<li>把要生成的元素x*x的表达式写在for循环前面</li>
</ul>
</li>
<li>使用if…else语句<ul>
<li>如[x for x in range(1, 11) if x % 2 == 0]</li>
<li>但不能在if后加上else</li>
<li>如果if语句写在for前面，则需要加上else</li>
<li>如[x if x % 2 == 0 else -x for x in range(1, 11)]</li>
<li>因为for前面必须是一个表达式，且能计算出结果</li>
</ul>
</li>
</ul>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul>
<li>生成器generator，能一边循环一边计算<ul>
<li>如(x*x for x in range(10))</li>
</ul>
</li>
<li>与列表生成式的差别仅在于最外层的 [] 和 ()</li>
<li>打印一个generator的方式<ul>
<li>next()函数</li>
<li>但通常使用for循环，因为generator是一个可迭代对象</li>
</ul>
</li>
<li>关键字yield，如果一个函数定义中包括yield关键字，那么这个函数就是一个generator</li>
<li>普通函数是顺序执行，遇到return语句或最后一行函数语句就返回，而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，下次重新重新从yield语句执行</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>可以直接使用for循环的数据类型有<ul>
<li>集合数据类型，如list，tuple，dict，set，str，等</li>
<li>generator，包括生成器和带yield的generator function</li>
</ul>
</li>
<li>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable</li>
<li>可以使用isinstance()判断一个对象是否是Iterable对象</li>
<li>而可以被next()函数调用不断返回下一个值的对象称为迭代器：Iterator</li>
<li>可以使用isinstance()判断一个对象是否是Iterator对象</li>
<li>生成器都是Iterator</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>高级特性</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>DevSidecar开启增强模式</title>
    <url>/2021/09/19/DevSidecar%E5%BC%80%E5%90%AF%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>关于<a href="https://github.com/docmirror/dev-sidecar">DevSidecar</a>：开发者边车，命名取自service-mesh的service-sidecar，意为为开发者打辅助的边车工具<br>通过本地代理的方式将https请求代理到一些国内的加速通道上</li>
<li>ps：不得不说大佬的加密手法着实nb，有自信的可以忽略以下视频，自己尝试通过软件中的提示自行找出，<del>反正我是想不到＞﹏＜</del></li>
<li>开启了增强模式就可以愉快的通过goole访问各种技术网站了，请自行使用，切勿传播</li>
</ul>
<h2 id="DevSidecar开启增强模式"><a href="#DevSidecar开启增强模式" class="headerlink" title="DevSidecar开启增强模式"></a>DevSidecar开启增强模式</h2><div style="position: relative; padding: 30% 45%;">
<iframe 
        style="position: absolute; 
        width: 100%; 
        height: 100%; 
        left: 0; top: 0;" 
        src="https://player.bilibili.com/player.html?aid=503646988&bvid=BV1Yg411g7u8&cid=369965625&page=1&as_wide=1&high_quality=1&danmaku=0" 
        frameborder="no"
        allowfullscreen="true" 
        scrolling="no">
</iframe>
</div>]]></content>
      <categories>
        <category>浏览器增强</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之高阶函数</title>
    <url>/2021/09/21/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul>
<li>变量可以指向函数</li>
<li>而函数名也是变量<ul>
<li>a = abs(-10)</li>
<li>print(a)</li>
<li>10</li>
<li>abs = 5</li>
<li>print(abs)</li>
<li>5</li>
</ul>
</li>
<li>对于abs()这个函数，可以把函数名abs看成变量，它指向一个可以计算绝对值的函数</li>
<li>而当将abs指向5后，就无法通过abs()调用函数，因为它已经不指向求绝对值函数，而是指向一个整数5，而在实际编程中绝对不能这么写！</li>
<li>传入函数</li>
<li>当一个函数接受另一个函数作为参数时，这种函数就称为高阶函数<ul>
<li>def add(x, y, f):<ul>
<li>return f(x) + f(y)</li>
</ul>
</li>
<li>print(add(-5, 6, abs))</li>
</ul>
</li>
</ul>
<hr>
<h3 id="map和reduce"><a href="#map和reduce" class="headerlink" title="map和reduce"></a>map和reduce</h3><ul>
<li>Python内建了map()和reduce()函数</li>
<li>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterable返回<ul>
<li>def f(x):<ul>
<li>return x * x</li>
</ul>
</li>
<li>r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</li>
<li>print(list(r))</li>
</ul>
</li>
<li>reduce()函数接收两个参数，一个是函数，一个是Iterable，reduce把结果继续和序列的下一个元素做累积计算<ul>
<li>reduce(f, [x1, x2, x3, x4,]) = f(f(f(x1, x2), x3), x4)</li>
</ul>
</li>
<li>使用reduce要在程序前导入<ul>
<li>from functools import reduce</li>
</ul>
</li>
</ul>
<hr>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul>
<li>Python内建的filter()函数用于过滤序列</li>
<li>filter()和map()相似也是接收一个函数和一个序列，不过filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False来决定保留还是丢弃该元素<ul>
<li>def is_odd(n):<ul>
<li>return n % 2 == 1</li>
</ul>
</li>
<li>list(filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</li>
</ul>
</li>
<li>注意filter()函数返回的是一个Iterator，也就是一个惰性序列，所有要获得filter()完成计算的所有结果，需要用list()函数</li>
</ul>
<hr>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><ul>
<li>Python内置的sorted()函数可以对list进行排序<ul>
<li>sorted([36, 5, -12, 9, -21])</li>
<li>[-21, -12, 5, 9, 36]</li>
</ul>
</li>
<li>sorted()函数也是一个高阶函数，可以接收一个key函数来实现自定义的排序<ul>
<li>sorted([36, 5, -12, 9, -21], key=abs)</li>
<li>[5, 9, -12, -21, 36]</li>
</ul>
</li>
<li>sorted()函数的第三个参数，可以决定是否反转结果<ul>
<li>sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower, reverse=True)</li>
<li>[‘Zoo’, ‘Credit’, ‘bob’, ‘about’]</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>高阶函数</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之数据类型</title>
    <url>/2021/09/16/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h1><ul>
<li>Python使用缩进来组织代码块，确保不混用Tab和空格</li>
<li>Python程序是大小写敏感的</li>
<li>Python是动态语言</li>
<li>变量本身类型不固定的语言称之为动态语言，与之相对的静态语言，静态语言在定义变量时必须指定变量类型</li>
</ul>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ol>
<li>python可以处理任意大小的整数</li>
<li>可以使用十六进制来方便的表示二进制<ul>
<li>0x前缀和0-9，a-f表示</li>
</ul>
</li>
<li>10_000_000与10000000是完全一样的</li>
<li>整数运算永远是精准的</li>
<li>在Python中有两种除法<ul>
<li>一种除法是/，计算结果是浮点数</li>
<li>还有一种是//，称为地板除，计算结果是整数</li>
</ul>
</li>
<li>取余，%</li>
</ol>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ol>
<li>按照科学计数法表示时，一个浮点数的小数点位置是可变的<ul>
<li>1.23e9==12.3e8</li>
</ul>
</li>
<li>用科学计数法表示时，把10用e代替</li>
</ol>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li>表示文本时，可以使用’    ‘，或”    “</li>
<li>转义字符\<ul>
<li>\n表示换行，\t表示制表，\表示\</li>
<li>为了简化，Python允许使用r’    ‘表示’ ‘内部的字符串默认不转义</li>
</ul>
</li>
<li>表示多行内容’’’…’’’<ul>
<li>例如：print(‘’’line1…line2…line3’’’)</li>
</ul>
</li>
</ol>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><ol>
<li>取值True和False，运算and，or，not</li>
</ol>
<h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><ol>
<li>空值是Python中一个特殊的值，用None表示，</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li>变量名必须是大小写英文，数字和_的组合，且不能用数字开头</li>
</ol>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ol>
<li>在Python中，通常用全部大写的变量名表示常量，如PI</li>
<li>但事实上PI仍是一个变量</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>关于搭建blog时踩过的坑</title>
    <url>/2021/09/15/%E5%85%B3%E4%BA%8E%E6%90%AD%E5%BB%BAblog%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="搭建工具："><a href="#搭建工具：" class="headerlink" title="搭建工具："></a>搭建工具：</h2><ul>
<li><a href="https://git-scm.com/downloads">git</a></li>
<li><a href="http://nodejs.cn/download/">node.js</a></li>
</ul>
<h2 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h2><h3 id="git："><a href="#git：" class="headerlink" title="git："></a>git：</h3><ol>
<li>下载并安装好</li>
<li>了解关于git的基本概念和指令，推荐这个：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">有关git的教程</a><br>git作为github使用的重要工具，可单独进行深入学习，了解git（目前世界上最先进的分布式版本控制系统）有助于在github进行项目开发</li>
</ol>
<h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><ol>
<li><p>下载并安装好</p>
</li>
<li><p>坑：</p>
<ol>
<li>当使用 node -v、npm -v 指令发现没问题时，软件其实已经就已经安装好了，但当我在修改全局依赖包下载路径后，并试图使用 npm install @vue/cli -g 指令测试修改结果时，总会出现许多奇奇怪怪的安装失败错误<ul>
<li>提示没有权限</li>
<li>提示路径信息错误</li>
</ul>
</li>
</ol>
<p> 解决方法：无权限则以管理员身份启动cmd，路径错误则删除用户目录下 .npmrc 文件</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>搭建blog</tag>
      </tags>
  </entry>
  <entry>
    <title>测试各种东西...</title>
    <url>/2021/08/19/%E6%B5%8B%E8%AF%95%E5%90%84%E7%A7%8D%E4%B8%9C%E8%A5%BF/</url>
    <content><![CDATA[<h2 id="嵌入哔哩哔哩-bilibili-视频"><a href="#嵌入哔哩哔哩-bilibili-视频" class="headerlink" title="嵌入哔哩哔哩(bilibili)视频"></a>嵌入哔哩哔哩(bilibili)视频</h2><div style="position: relative; padding: 30% 45%;">
<iframe 
        style="position: absolute; 
        width: 100%; 
        height: 100%; 
        left: 0; top: 0;" 
        src="https://player.bilibili.com/player.html?aid=758772694&bvid=BV1V64y19758&cid=359450650&page=1&as_wide=1&high_quality=1&danmaku=0" 
        frameborder="no"
        allowfullscreen="true" 
        scrolling="no">
</iframe>
</div>
]]></content>
      <categories>
        <category>测试</category>
        <category>页面元素</category>
      </categories>
      <tags>
        <tag>页面元素</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode刷题必备知识</title>
    <url>/2021/10/06/Leetcode%E5%88%B7%E9%A2%98%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>这是一个会持续更新的文章，主要内容为在刷Leetcode时遇到的各种Java基础知识点</li>
<li>建议ctrl+F搜索查看</li>
</ul>
<hr>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><ul>
<li>HashMap 是一个散列表，它存储的内容是键值对 (key-value) 映射</li>
<li>HashMap 是无序的，即不会记录插入的顺序<ul>
<li>Map&lt;String, String&gt;map = new HashMap();</li>
</ul>
</li>
<li>添加键值对可以使用 put() 方法<ul>
<li>map.put(1, “Google”);</li>
</ul>
</li>
<li>使用 get(key) 方法来获取 key 对应的 value<ul>
<li>map.get(1)</li>
</ul>
</li>
<li>使用 remove(key) 方法来删除key对应的键值对 (key-value)<ul>
<li>map.remove(1)</li>
<li>删除所有键值对 (key-value) 可以使用 clear 方法<ul>
<li>map.clear();</li>
</ul>
</li>
</ul>
</li>
<li>计算 HashMap 中的元素数量可以使用 size() 方法<ul>
<li>map.size();</li>
</ul>
</li>
<li>迭代 HashMap 可以使用 for-each <ul>
<li>获取键值对 (key-value)<ul>
<li>for(Integer i : map){}</li>
</ul>
</li>
</ul>
</li>
<li>检查 hashMap 中是否存在指定的 key 对应的映射关系<ul>
<li>map.containsKey();</li>
</ul>
</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>父类的引用指向子类的对象</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>replaceAll() 方法使用给定的参数 replacement 替换字符串所有匹配给定的正则表达式的子字符串。<ul>
<li>public String replaceAll(String regex, String replacement)</li>
</ul>
</li>
<li>字符串格式化方法<ul>
<li>String.format(“格式+占位符”, string1, string2…);</li>
</ul>
</li>
<li>StringBuilder类<ul>
<li>用于解决字符串频繁修改带来的内存消耗</li>
<li>当有频繁修改字符串内容这样的操作时，首选使用</li>
<li>StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用</li>
</ul>
</li>
<li>创建<ul>
<li>StringBuilder builder = new StringBuilder();</li>
<li>StringBuilder builder = new StringBuilder(“helloworld”);</li>
</ul>
</li>
<li>追加字符串<ul>
<li>builder.append(String str);</li>
</ul>
</li>
<li>插入字符串<ul>
<li>builder.insert(int dstOffset,String s);</li>
</ul>
</li>
<li>删除字符串<ul>
<li>builder.delete(int start,int end);</li>
</ul>
</li>
<li>替换字符串<ul>
<li>builder.replace(int start,int end,String str);</li>
</ul>
</li>
<li>字符串反转<ul>
<li>builder.reverse();</li>
</ul>
</li>
<li>将StringBuilder类转换为String<ul>
<li>builder.toString();</li>
</ul>
</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>基本类型<ul>
<li>byte：byte 数据类型是8位</li>
<li>short：short 数据类型是 16 位</li>
<li>int：int 数据类型是32位</li>
<li>long：long 数据类型是 64 位</li>
<li>float：float 数据类型是单精度、32位</li>
<li>double：double 数据类型是双精度、64 位</li>
<li>boolean：boolean数据类型表示一位的信息</li>
<li>char：char 类型是一个单一的 16 位 Unicode 字符</li>
</ul>
</li>
<li>对象类型<ul>
<li>Byte</li>
<li>Short</li>
<li>Integer</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Boolean</li>
<li>Character </li>
</ul>
</li>
</ul>
<h1 id="Math库"><a href="#Math库" class="headerlink" title="Math库"></a>Math库</h1><ul>
<li>Math.pow(x, y)<ul>
<li>pow() 方法可以返回 x 的 y 次幂的值</li>
</ul>
</li>
</ul>
<h1 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h1><ul>
<li>是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合</li>
<li>Iterator 是 Java 迭代器的简单实现</li>
<li>导包<ul>
<li>import java.util.Iterator;</li>
</ul>
</li>
<li>获取迭代器<ul>
<li>先要有迭代对象</li>
<li>ArrayList<String> sites = new ArrayList<String>();</li>
<li>Iterator<String> iter = sites.iterator();</li>
</ul>
</li>
<li>迭代器常用方法<ul>
<li>返回迭代器的下一个元素<ul>
<li>iter.next();</li>
</ul>
</li>
<li>检测集合中是否还有元素<ul>
<li>iter.hasNext()</li>
</ul>
</li>
<li>将迭代器返回的元素删除<ul>
<li>iter.remove();</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><ul>
<li>特点：不能存储相同的元素，是一个无序集合(输出顺序与放入顺序无关)</li>
<li>因为是一个抽象的接口，所以不能直接实例化一个set对象<ul>
<li>如：错误示范(Set s = new Set())</li>
</ul>
</li>
<li>该接口主要继承于Collection接口，所以有Collection的一些常见方法<ul>
<li>向集合添加元素：add()</li>
<li>判断集合是否包含某一个元素：contains()</li>
<li>判断集合是否为空：isEmpty()</li>
<li>递归集合，返回一个Iterator()对象：iterator()</li>
<li>返回集合大小：size()</li>
</ul>
</li>
<li>Set接口常用的两大实现<ul>
<li>HashSet<ul>
<li>哈希表结构</li>
<li>元素无序</li>
</ul>
</li>
<li>TreeSet<ul>
<li>红黑树结构</li>
<li>会将元素默认排序（升序）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><ul>
<li>特点：可以存储相同的元素，是一个有序集合(输出顺序与放入顺序有关)</li>
<li>List是一个接口，继承于Collection接口</li>
<li>List接口常用的两大实现<ul>
<li>ArrayList<ul>
<li>是用数组实现的，可认为是一个可改变大小的动态数组</li>
<li>适用于查找</li>
</ul>
</li>
<li>LinkedList<ul>
<li>是用双向链表实现的</li>
<li>适用于增删</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础之面向对象编程</title>
    <url>/2021/10/07/Python%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><ul>
<li>Object Oriented Programming，简称OOP，是一种程序设计思想</li>
<li>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小函数来降低系统的复杂度</li>
<li>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递</li>
<li>Python中，所有数据类型都可以视为对象，也可以自定义对象</li>
<li>创建一个类<ul>
<li>class Student(object):<ul>
<li>def __init__(self, name, score):<ul>
<li>self.name = name</li>
<li>self.score = score</li>
</ul>
</li>
<li>def print_score(self):<ul>
<li>print(‘%s: %s’ % (self.name, self.score))</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>创建一个实例(对象)<ul>
<li>bart = Student(‘Bart’, 56)</li>
<li>bart.print_score()</li>
</ul>
</li>
<li>解读以上代码<ul>
<li>class：定义类的关键字</li>
<li>Student：类名</li>
<li>(object)：表明该类是从哪个类继承下来的，通常如果没有合适的继承类，就使用object类</li>
<li>__init__：特殊方法，可以在创建实例时，把一些我们认为必须绑定的属性强制填写进去<ul>
<li>self：该方法的第一个参数永远是self，表示创建的实例本身</li>
</ul>
</li>
<li>print_score：类中定义的方法</li>
<li>Student()：创建实例是通过类名+()实现的</li>
</ul>
</li>
<li>可以自由的给一个实例变量绑定属性<ul>
<li>bart.age = 8    </li>
</ul>
</li>
<li>总结<ul>
<li>类是创建实例的模版，而实例是一个个具体的对象，各个实例拥有的数据都互相独立，互不影响</li>
<li>python允许对实例变量绑定任何数据，也就是说同一个类的实例，拥有的变量名都可能不同</li>
</ul>
</li>
</ul>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><ul>
<li>在class内部，类可以有自己的属性和方法，而我们可以直接通过实例来操作数据</li>
<li>如修改 bart 实例的 score 属性<ul>
<li>bart.score = 100</li>
<li>print(bart.score)</li>
<li>100</li>
</ul>
</li>
<li>如果要限制外部对类中内部属性的访问，可以在属性名前加 __ (双下划线)<ul>
<li>class Student(object):<ul>
<li>def__init__(self, name, score):<ul>
<li>self.__name = name</li>
<li>self.score = score</li>
</ul>
</li>
<li>def print_score(self):<ul>
<li>print(‘%s: %s’ % (self.__name, self.__score))</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>这时就无法从外部访问 bart.__name 和 bart.__score<ul>
<li>在 VisualStudio2019 中会出现这么一个错误<ul>
<li>‘Student’ object has no attribute ‘__name’</li>
</ul>
</li>
<li>表明该变量不可被访问</li>
</ul>
</li>
<li>如果要访问和修改被 __ 修饰的属性，可以给Student类增加getter和setter方法<ul>
<li>def get_score(self):<ul>
<li>return self.__name</li>
</ul>
</li>
<li>def set_score(self, score):<ul>
<li>self.__score = score</li>
</ul>
</li>
<li>这种控制变量的方式，可以防止无效数据的输入</li>
</ul>
</li>
<li>注意<ul>
<li>在python中，类似于这样的变量名 __xxx__，以双下划线开头，并且以双下划线结尾的，是特殊变量，可以直接被外部访问</li>
<li>而双下划线开头的变量 __xxx，其实也可以被外部访问，通过_Student__score<ul>
<li>print(mark._Student__score)</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode刷题之不用除号的除法</title>
    <url>/2021/10/13/Leetcode%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%8D%E7%94%A8%E9%99%A4%E5%8F%B7%E7%9A%84%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><ul>
<li>此题是加减乘除的进阶版，即不使用除号来实现除法，需要运用到位运算的有关知识</li>
<li><a href="https://leetcode-cn.com/problems/divide-two-integers/">Leetcode_两数相除</a></li>
<li><a href="https://leetcode-cn.com/problems/divide-two-integers/solution/gong-shui-san-xie-dui-xian-zhi-tiao-jian-utb9/">思路借鉴</a></li>
</ul>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</li>
<li>返回被除数 dividend 除以除数 divisor 得到的商。</li>
<li>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两数相除</span></span><br><span class="line">    <span class="comment">//三叶一，不限制long</span></span><br><span class="line">    <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span></span>&#123;   <span class="comment">//除数，被除数</span></span><br><span class="line">        <span class="keyword">long</span> a = dividend, b = divisor;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>) || (a &gt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>))&#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = Math.abs(a);</span><br><span class="line">        b = Math.abs(b);</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">0</span>, r = a;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">long</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mul(mid, b) &lt;= a)&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r = flag ? -r : r;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; INF || r &lt; -INF - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        总结：关于使用二分法，来慢慢逼近答案</span></span><br><span class="line"><span class="comment">        a / b = x，a为被除数，b为除数，c为答案</span></span><br><span class="line"><span class="comment">        设答案为x，则在数轴上以x为分割点，对于小于x的数来说，有 x * b &lt; a，对于大于x的数来说，有 x * b &gt; a</span></span><br><span class="line"><span class="comment">        则设初始 l(left) 为 0，r(right) 为 a</span></span><br><span class="line"><span class="comment">        mid = l + r + 1 &gt;&gt; 1</span></span><br><span class="line"><span class="comment">        判断 mid * b，若小于 a，则使左边界为 mid，若大于 a，则使右边界为 mid - 1。</span></span><br><span class="line"><span class="comment">        如此反复，直到 l == r，即左边界等于右边界，就是答案</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不用乘法符号的乘法（づ￣3￣）づ</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;      <span class="comment">//判断奇偶，奇数就为真</span></span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        总结：对于以位运算实现乘法</span></span><br><span class="line"><span class="comment">        设a, k为乘数</span></span><br><span class="line"><span class="comment">        当 k&gt;0 时进入循环，首先判断k的奇偶，奇数就使ans += a，偶数就跳过</span></span><br><span class="line"><span class="comment">        然后使k的二进制右移（相当于除二，但实际上是二进制高位补零，舍去低位的一位）</span></span><br><span class="line"><span class="comment">        a翻倍，a += a，相当于乘二</span></span><br><span class="line"><span class="comment">        好特么神奇(ToT)/~~~</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h2 id="对位运算的总结"><a href="#对位运算的总结" class="headerlink" title="对位运算的总结"></a>对位运算的总结</h2><ul>
<li>右移一的位运算：(可近似看为除二)，如果该数为正，则高位补0，若为负数，则高位补1，舍去最低的那位</li>
<li>例如：5 &gt;&gt;= 1<ul>
<li>0101 —&gt; 0010</li>
<li>由 5 变成了 2</li>
</ul>
</li>
<li>左移一的位运算：左移时不管正负，低位补0</li>
<li>例如：5 &lt;&lt;= 1<ul>
<li>0101 —&gt; 01010</li>
<li>由 5 变成了10</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
